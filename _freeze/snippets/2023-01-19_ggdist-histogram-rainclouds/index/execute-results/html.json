{
  "hash": "6a83f435cce2fb16d806613edc14666a",
  "result": {
    "markdown": "---\ntitle: \"Histogram raincloud plots\"\ndescription: |\n  Making raincloud plots for discrete numerical data with {ggdist}.\n\ndate: 2023-01-19\n\ncategories:\n  - .Visualize\n  - \"{ggplot2}\"\n  - \"{ggdist}\"\n\nparams:\n  use_renv: FALSE\n  data_file: NULL # Filename of data located in /data/\n  fair_dealing: FALSE\n---\n\n\n\n\n## Prerequisites\n\nTo access the datasets, help pages, and functions that we will use in this code snippet, load the following packages:\n\n\n::: {.cell opts.label='no.message'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(ggdist)\nlibrary(palettes)\nlibrary(forcats)\n```\n:::\n\n\n## Rationale\n\n[Likert scales](https://en.wikipedia.org/wiki/Likert_scale) are a commonly used measurement tool in surveys. A typical Likert scale is made of multiple items measuring respondent's attitudes towards different statements (e.g., \"The prime minister is doing a good job\", \"The senate is doing a good job\", etc.).\n\nAttitudes towards each statement are then measured with a rating scale like:\n\n::: {style=\"overflow: scroll\"}\n> Please indicate how much you agree or disagree with each of these statements:\n>\n> | | Strongly disagree | Somewhat disagree | Neither agree nor disagree | Somewhat agree | Strongly agree |\n|:----------------------------------------|:---:|:---:|:---:|:---:|:---:|\n| The prime minister is doing a good job. |  1  |  2  |  3  |  4  |  5  |\n| The senate is doing a good job.         |  1  |  2  |  3  |  4  |  5  |\n:::\n\nBecause items in a Likert scale are numeric but discrete, a density histogram is an ideal way to visualize the distribution of responses to each item (as opposed to the density curve [typically used in raincloud plots with continuous data](https://www.cedricscherer.com/2021/06/06/visualizing-distributions-with-raincloud-plots-and-how-to-create-them-with-ggplot2/)).\n\n### Why not a density curve?\n\nWhile it is possible to use a density curve, doing so should make it immediately obvious why it isn't a great approach for discrete numeric data like this:\n\n- The density curve masks notable differences in density between different scores\n- The outermost fills in the density curve are cut off when it is trimmed to the range of the input data\n- The density curve goes far beyond the possible values of the data when it isn't trimmed[^1]\n\n[^1]: It also makes it difficult to get the fill breaks right, hence the lack of any fill colours in the `trim = FALSE` example.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell layout-ncol=\"2\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(likert_scores, aes(x = score, y = item)) +\n  stat_slab(\n    aes(fill = cut(after_stat(x), breaks = breaks(x))),\n    justification = -.2,\n    height = 0.7,\n    slab_colour = \"black\",\n    slab_linewidth = 0.5,\n    trim = TRUE\n  ) +\n  geom_boxplot(\n    width = .2,\n    outlier.shape = NA\n  ) +\n  geom_jitter(width = .1, height = .1, alpha = .3) +\n  scale_fill_manual(\n    values = pal_ramp(met_palettes$Hiroshige, 5, -1),\n    labels = 1:5,\n    guide = guide_legend(title = \"score\", reverse = TRUE)\n  )\n```\n\n::: {.cell-output-display}\n![`trim = TRUE`](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(likert_scores, aes(x = score, y = item)) +\n  stat_slab(\n    justification = -.2,\n    height = 0.7,\n    slab_colour = \"black\",\n    slab_linewidth = 0.5,\n    trim = FALSE\n  ) +\n  geom_boxplot(\n    width = .2,\n    outlier.shape = NA\n  ) +\n  geom_jitter(width = .1, height = .1, alpha = .3) +\n  scale_x_continuous(breaks = 1:5)\n```\n\n::: {.cell-output-display}\n![`trim = FALSE`](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n\nHowever, each of these problems is easily solved by using a density histogram instead.\n\n## Histogram raincloud plots\n\nFirst make some data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\nlikert_scores <- data.frame(\n  item = rep(letters[1:2], times = 33),\n  score = sample(1:5, 66, replace = TRUE)\n)\n```\n:::\n\n\nIt's straightforward to make density histograms for each item with **ggplot2**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(likert_scores, aes(x = score, y = after_stat(density))) +\n  geom_histogram(\n    aes(fill = after_stat(x)),\n    bins = 5,\n    colour = \"black\"\n  ) +\n  scale_fill_gradientn(\n    colours = pal_ramp(met_palettes$Hiroshige, 5, -1),\n    guide = guide_legend(title = \"score\", reverse = TRUE)\n  ) +\n  facet_wrap(vars(fct_rev(item)), ncol = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nHowever, the density histograms in this plot can't be vertically justified to give space for the box and whiskers plot and points used in a typical raincloud plot. For that we need the `stat_slab()` function from the **ggdist** package and a small helper function to determine where to put breaks in the histogram.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Set breaks so bins are centred on each score\n#'\n#' @param x A vector of values.\n#' @param width Any value between 0 and 0.5 for setting the width of the bins\nbreaks <- function(x, width = 0.49999999) {\n  rep(1:max(x), each = 2) + c(-width, width)\n}\n```\n:::\n\n\nThe default slab type for `stat_slab()` is a probability density (or mass) function (`\"pdf\"`), but it can also calculate density histograms (`\"histogram\"`). To match the appearance of `geom_histogram()`, the `breaks` argument needs to be given the location of each bin's left and right edge; this also necessitates using `cut()` with the fill aesthetic so the fill breaks correctly align with each bin.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(likert_scores, aes(x = score, y = item)) +\n  stat_slab(\n    # Divide fill into five equal bins\n    aes(fill = cut(after_stat(x), breaks = 5)),\n    slab_type = \"histogram\",\n    breaks = \\(x) breaks(x),\n    # Justify the histogram upwards\n    justification = -.2,\n    # Reduce the histogram's height so it doesn't cover geoms from other items\n    height = 0.7,\n    # Add black outlines because they look nice\n    slab_colour = \"black\",\n    outline_bars = TRUE,\n    slab_linewidth = 0.5\n  ) +\n  geom_boxplot(\n    width = .2,\n    # Hide outliers since the raw data will be plotted\n    outlier.shape = NA\n  ) +\n  geom_jitter(width = .1, height = .1, alpha = .3) +\n  # Cutting the fill into bins puts it on a discrete scale\n  scale_fill_manual(\n    values = pal_ramp(met_palettes$Hiroshige, 5, -1),\n    labels = 1:5,\n    guide = guide_legend(title = \"score\", reverse = TRUE)\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n## {.appendix .unnumbered .unlisted}\n\n::: {.d-flex}\n\n![](/assets/images/avatar.png){fig-align=\"left\" fig-alt=\"Avatar\" .rounded .avatar}\n\n::: {}\n\n::: {}\n## Michael McCarthy {.quarto-appendix-heading}\n:::\n\nThanks for reading! I’m Michael, the voice behind Tidy Tales. I am an award winning data scientist and R programmer with the skills and experience to help you solve the problems you care about. You can learn more about me, my [consulting services](https://michaelmccarthy.tidytales.ca/consulting/), and my other projects on my [personal website](https://michaelmccarthy.tidytales.ca).\n:::\n\n:::\n\n## Comments {.appendix .unnumbered .unlisted}\n\n<details open>\n<summary></summary>\n::: {.giscus}\n:::\n</details>\n\n## Session Info {.appendix .unnumbered .unlisted}\n\n<details>\n<summary></summary>\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.2.2 (2022-10-31)\n os       macOS Mojave 10.14.6\n system   x86_64, darwin17.0\n ui       X11\n language (EN)\n collate  en_CA.UTF-8\n ctype    en_CA.UTF-8\n tz       America/Vancouver\n date     2023-01-20\n pandoc   2.14.0.3 @ /Applications/RStudio.app/Contents/MacOS/pandoc/ (via rmarkdown)\n quarto   1.2.313 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n forcats     * 0.5.2   2022-08-19 [1] CRAN (R 4.2.0)\n ggdist      * 3.2.1   2023-01-18 [1] CRAN (R 4.2.2)\n ggplot2     * 3.4.0   2022-11-04 [1] CRAN (R 4.2.0)\n palettes    * 0.1.0   2022-12-19 [1] CRAN (R 4.2.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.2.0)\n\n [1] /Users/Michael/Library/R/x86_64/4.2/library/__tidytales\n [2] /Library/Frameworks/R.framework/Versions/4.2/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n</details>\n\n<!--\n## Data {.appendix .unnumbered .unlisted}\n\n[Download](/data/) the data used in this post.\n-->\n\n<!--\n## Fair Dealing {.appendix .unnumbered .unlisted}\n\nAny of the trademarks, service marks, collective marks, design rights or similar rights that are mentioned, used, or cited in this article are the property of their respective owners. They are used here as fair dealing for the purpose of education in accordance with [section 29 of the Copyright Act](https://laws-lois.justice.gc.ca/eng/acts/c-42/page-8.html#h-103270) and do not infringe copyright.\n-->\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}